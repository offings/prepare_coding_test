## 백준 6603 로또
[문제 링크](https://www.acmicpc.net/problem/6603)

## 문제
독일 로또는 {1, 2, ..., 49}에서 수 6개를 고른다.

로또 번호를 선택하는데 사용되는 가장 유명한 전략은 49가지 수 중 k(k>6)개의 수를 골라 집합 S를 만든 다음 그 수만 가지고 번호를 선택하는 것이다.

예를 들어, k=8, S={1,2,3,5,8,13,21,34}인 경우 이 집합 S에서 수를 고를 수 있는 경우의 수는 총 28가지이다. ([1,2,3,5,8,13], [1,2,3,5,8,21], [1,2,3,5,8,34], [1,2,3,5,13,21], ..., [3,5,8,13,21,34])

집합 S와 k가 주어졌을 때, 수를 고르는 모든 방법을 구하는 프로그램을 작성하시오.

## 핵심 포인트
```
- 기본 백트래킹의 원리, combinations 함수를 이용한 풀이 모두가 가능하다.
- 다만 백트래킹으로 조합을 구하기 위해서는 현재 삽입하려는 값이 stack에 있는 마지막 값보다 커야 한다. (stack이 비어있다면 해당 조건은 검사하지 않는다.)
```

## 핵심 코드
> 백트래킹을 이용한 풀이 방법
```
def back_tracking(count):
    if count == 6:
        print(*stack)
        return

    for i in range(k):
        # 조합을 구해야 하므로 항상 stack의 마지막 값보다 삽입하려는 값이 커야 함
        # and 뒤 해당 조건이 없으면 순열과 동일
        if s[i] not in stack and (not stack or s[i] > stack[-1]):
            stack.append(s[i])
            back_tracking(count + 1)
            stack.pop()
```

> combinations 함수를 이용한 풀이 방법
```
comb = list(combinations(s, 6))
```
