## 백준 16935 배열 돌리기 3
[문제 링크](https://www.acmicpc.net/problem/16935)

## 문제
크기가 N×M인 배열이 있을 때, 배열에 연산을 R번 적용하려고 한다. 연산은 총 6가지가 있다.

1번 연산은 배열을 상하 반전시키는 연산이다.

1 6 2 9 8 4 → 4 2 9 3 1 8  
7 2 6 9 8 2 → 9 2 3 6 1 5  
1 8 3 4 2 9 → 7 4 6 2 3 1  
7 4 6 2 3 1 → 1 8 3 4 2 9    
9 2 3 6 1 5 → 7 2 6 9 8 2  
   <배열>       <연산 결과>  
2번 연산은 배열을 좌우 반전시키는 연산이다.

1 6 2 9 8 4 → 4 8 9 2 6 1  
7 2 6 9 8 2 → 2 8 9 6 2 7  
1 8 3 4 2 9 → 9 2 4 3 8 1  
7 4 6 2 3 1 → 1 3 2 6 4 7  
9 2 3 6 1 5 → 5 1 6 3 2 9  
4 2 9 3 1 8 → 8 1 3 9 2 4  
   <배열>       <연산 결과>  
3번 연산은 오른쪽으로 90도 회전시키는 연산이다.

1 6 2 9 8 4 → 4 9 7 1 7 1  
7 2 6 9 8 2 → 2 2 4 8 2 6  
1 8 3 4 2 9 → 9 3 6 3 6 2  
7 4 6 2 3 1 → 3 6 2 4 9 9  
9 2 3 6 1 5 → 1 1 3 2 8 8  
4 2 9 3 1 8 → 8 5 1 9 2 4  
   <배열>       <연산 결과>  
4번 연산은 왼쪽으로 90도 회전시키는 연산이다.

1 6 2 9 8 4 → 4 2 9 1 5 8  
7 2 6 9 8 2 → 8 8 2 3 1 1  
1 8 3 4 2 9 → 9 9 4 2 6 3  
7 4 6 2 3 1 → 2 6 3 6 3 9    
9 2 3 6 1 5 → 6 2 8 4 2 2  
4 2 9 3 1 8 → 1 7 1 7 9 4  
   <배열>       <연산 결과>  
5, 6번 연산을 수행하려면 배열을 크기가 N/2×M/2인 4개의 부분 배열로 나눠야 한다. 아래 그림은 크기가 6×8인 배열을 4개의 그룹으로 나눈 것이고, 1부터 4까지의 수로 나타냈다.

1 1 1 1 2 2 2 2  
1 1 1 1 2 2 2 2  
1 1 1 1 2 2 2 2  
4 4 4 4 3 3 3 3    
4 4 4 4 3 3 3 3  
4 4 4 4 3 3 3 3  
5번 연산은 1번 그룹의 부분 배열을 2번 그룹 위치로, 2번을 3번으로, 3번을 4번으로, 4번을 1번으로 이동시키는 연산이다.

3 2 6 3 1 2 9 7 → 2 1 3 8 3 2 6 3  
9 7 8 2 1 4 5 3 → 1 3 2 8 9 7 8 2  
5 9 2 1 9 6 1 8 → 4 5 1 9 5 9 2 1  
2 1 3 8 6 3 9 2 → 6 3 9 2 1 2 9 7  
1 3 2 8 7 9 2 1 → 7 9 2 1 1 4 5 3  
4 5 1 9 8 2 1 3 → 8 2 1 3 9 6 1 8  
     <배열>            <연산 결과>  
6번 연산은 1번 그룹의 부분 배열을 4번 그룹 위치로, 4번을 3번으로, 3번을 2번으로, 2번을 1번으로 이동시키는 연산이다.

3 2 6 3 1 2 9 7 → 1 2 9 7 6 3 9 2  
9 7 8 2 1 4 5 3 → 1 4 5 3 7 9 2 1  
5 9 2 1 9 6 1 8 → 9 6 1 8 8 2 1 3  
2 1 3 8 6 3 9 2 → 3 2 6 3 2 1 3 8  
1 3 2 8 7 9 2 1 → 9 7 8 2 1 3 2 8  
4 5 1 9 8 2 1 3 → 5 9 2 1 4 5 1 9  
     <배열>            <연산 결과>  

## 핵심 포인트
```
- 번호에 따라 다른 연산을 수행해야 하므로 각각의 연산 규칙을 파악해야 한다.
- 연산을 여러 번 해야 할 경우는 a 배열의 값을 연산이 끝난 후 꼭 업데이트해야 한다.
```

## 핵심 코드
```
for o in oper:
    # 번호가 1일 때는 상하반전
    if o == 1:
        for i in range(n - 1, -1, -1):
            for j in range(m):
                pa[(n - 1) - i][j] = a[i][j]

    # 번호가 2일 때는 좌우반전
    elif o == 2:
        for i in range(n):
            for j in range(m - 1, -1, -1):
                pa[i][(m - 1) - j] = a[i][j]

    # 번호가 3일 때는 오른쪽으로 90도 회전
    elif o == 3:
        for i in range(n):
            for j in range(m):
                pa[j][(n - 1) - i] = a[i][j]
        n, m = m, n

    # 번호가 4일 때는 왼쪽으로 90도 회전
    elif o == 4:
        for i in range(n):
            for j in range(m):
                pa[(m - 1) - j][i] = a[i][j]
        n, m = m, n

    # 번호가 5일 때는 그룹 간 이동
    elif o == 5:
        half_row = n // 2
        half_col = m // 2

        # 1번 그룹을 2번 그룹으로 이동
        for i in range(half_row):
            for j in range(half_col):
                pa[i][j + half_col] = a[i][j]

        # 2번 그룹을 3번 그룹으로 이동
        for i in range(half_row):
            for j in range(half_col, m):
                pa[i + half_row][j] = a[i][j]

        # 3번 그룹을 4번 그룹으로 이동
        for i in range(half_row, n):
            for j in range(half_col, m):
                pa[i][j - half_col] = a[i][j]

        # 4번 그룹을 1번 그룹으로 이동
        for i in range(half_row, n):
            for j in range(half_col):
                pa[i - half_row][j] = a[i][j]

    # 번호가 6일 때는 역순으로 그룹 간 이동
    else:
        half_row = n // 2
        half_col = m // 2

        # 1번 그룹을 4번 그룹으로 이동
        for i in range(half_row):
            for j in range(half_col):
                pa[i + half_row][j] = a[i][j]

        # 2번 그룹을 1번 그룹으로 이동
        for i in range(half_row):
            for j in range(half_col, m):
                pa[i][j - half_col] = a[i][j]

        # 3번 그룹을 2번 그룹으로 이동
        for i in range(half_row, n):
            for j in range(half_col, m):
                pa[i - half_row][j] = a[i][j]

        # 4번 그룹을 3번 그룹으로 이동
        for i in range(half_row, n):
            for j in range(half_col):
                pa[i][j + half_col] = a[i][j]

    # 다시 연산을 수행할 배열 업데이트
    # 업데이트를 하지 않으면 연속된 연산을 수행할 수 없음
    a = [[0] * m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            a[i][j] = pa[i][j]
```
