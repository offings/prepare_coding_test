## 백준 12015 가장 긴 증가하는 부분 수열 2
[문제 링크](https://www.acmicpc.net/problem/12015)

## 문제
수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.

예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10, 20, 10, 30, 20, 50} 이고, 길이는 4이다.

## 핵심 포인트
```
- 수열의 크기가 최대 1,000,000이므로 반복문 2개를 사용하여 모든 값을 비교하려면 시간 초과 발생
- 현재 값이 부분 수열의 최댓값보다 크면 부분 수열에 삽입
- 현재 값이 부분 수열의 최댓값보다 작으면 부분 수열에서 현재 값이 들어갈 위치를 반환
- 인덱스를 찾는 방법은 1) bisect.bisect_left() 함수와 2) binary_search 두 가지가 있다.
```

## 알고리즘 추가 설명
```
입력 값 : [10, 20, 60, 30, 40]
현재 값이 부분 수열의 최댓값보다 클 경우만 고려한다면 가장 긴 부분 수열은 [10, 20, 60]이 된다. 따라서 현재 값이 부분 수열의 최댓값보다 작은 경우에 현재 값이 들어갈 수 있는 인덱스를 찾아 부분 수열의 값을 바꿔줘야 한다. 이렇게 알고리즘을 구성할 경우 가장 긴 부분 수열은 [10, 20, 30, 40]이 될 수 있다.
```

## 핵심 코드
> bisect 함수를 이용한 인덱스 위치 반환
```
import bisect
# bisect_left(arr, x) : 배열이 정렬되어 있다고 가정할 때, x가 들어갈 위치를 반환
idx = bisect.bisect_left(dp, num_list[i])
```

> binary_search를 구현하여 인덱스 위치 반환
```
def binary_search(search):
    start = 0
    end = len(dp) - 1

    while start <= end:
        mid = (start + end) // 2
        if dp[mid] == search:
            return mid
        elif dp[mid] > search:
            end = mid - 1
        else:
            start = mid + 1

    return start
```
