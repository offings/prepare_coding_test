## 백준 1261 알고스팟
[문제 링크](https://www.acmicpc.net/problem/1261)

## 문제
알고스팟 운영진이 모두 미로에 갇혔다. 미로는 N*M 크기이며, 총 1*1크기의 방으로 이루어져 있다. 미로는 빈 방 또는 벽으로 이루어져 있고, 빈 방은 자유롭게 다닐 수 있지만, 벽은 부수지 않으면 이동할 수 없다.

알고스팟 운영진은 여러명이지만, 항상 모두 같은 방에 있어야 한다. 즉, 여러 명이 다른 방에 있을 수는 없다. 어떤 방에서 이동할 수 있는 방은 상하좌우로 인접한 빈 방이다. 즉, 현재 운영진이 (x, y)에 있을 때, 이동할 수 있는 방은 (x+1, y), (x, y+1), (x-1, y), (x, y-1) 이다. 단, 미로의 밖으로 이동 할 수는 없다.

벽은 평소에는 이동할 수 없지만, 알고스팟의 무기 AOJ를 이용해 벽을 부수어 버릴 수 있다. 벽을 부수면, 빈 방과 동일한 방으로 변한다.

만약 이 문제가 알고스팟에 있다면, 운영진들은 궁극의 무기 sudo를 이용해 벽을 한 번에 다 없애버릴 수 있지만, 안타깝게도 이 문제는 Baekjoon Online Judge에 수록되어 있기 때문에, sudo를 사용할 수 없다.

현재 (1, 1)에 있는 알고스팟 운영진이 (N, M)으로 이동하려면 벽을 최소 몇 개 부수어야 하는지 구하는 프로그램을 작성하시오.

## 핵심 포인트
```
- 벽을 가능한 적게 부수어야 하므로 빈 방인 경우 queue에 삽입할 때 더 높은 우선순위를 가진다.
- 즉, 빈 방일 때는 queue에 삽입할 때 queue.appendleft()를 이용해서 해당 좌표를 더 빨리 방문하도록 코드를 구현한다.
```

## 핵심 코드
```
def bfs(x, y):
    queue = deque()
    queue.append([x, y])
    wall[x][y] = 0

    while queue:
        x, y = queue.popleft()
        # 목표 지점까지 도착하였다면 벽을 부순 횟수 출력 후 종료
        if x == n - 1 and y == m - 1:
            print(wall[x][y])
            break

        # 현재 위치에서 상하좌우로 이동가능한 좌표 탐색
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]

            # 해당 좌표를 방문한 적이 없고 범위를 벗어난 적이 없다면
            if 0 <= nx < n and 0 <= ny < n and wall[nx][ny] == -1:
                # 빈 방일 경우는 우선 탐색
                # 벽을 부수지 않아도 되므로 부순 횟수는 유지
                if maze[nx][ny] == 0:
                    queue.appendleft([nx, ny])
                    wall[nx][ny] = wall[x][y]
                # 벽일 경우는 queue에 삽입
                # 벽을 부수어야 하므로 부순 횟수 1 증가
                else:
                    queue.append([nx, ny])
                    wall[nx][ny] = wall[x][y] + 1
```
