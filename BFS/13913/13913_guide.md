## 백준 13913 숨바꼭질 4
[문제 링크](https://www.acmicpc.net/problem/13913)

## 문제
수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.

수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.

## 핵심 포인트
```
- 가장 빠른 시간을 구해야 하므로 BFS 알고리즘을 사용한다.
- 어떻게 이동해야 하는지 출력해야 하므로 dist 배열 외에 last 배열을 선언하여 이전의 노드를 저장한다.
- 처음 수빈이의 노드가 나올 때까지 반복문을 통하여 이전의 노드를 append 한다.
- 이동 경로가 담긴 배열을 역순으로 출력한다.
```

## 핵심 코드
```
def bfs(s):
    queue = deque()
    queue.append(s)

    # 최소 시간 정보가 담긴 배열
    dist[s] = 0
    # 이전 노드의 정보가 담긴 배열
    last[s] = -1

    while queue:
        x = queue.popleft()

        # 동생이 있는 위치가 발견되었을 때
        if x == k:
            # 동생이 있는 곳까지 최소 시간 출력
            print(dist[x])
            # 이동 경로를 순회하며 저장
            while last[x] != -1:
                answer.append(x)
                x = last[x]
            answer.append(x)
            # 이동 경로를 역순으로 출력
            print(*answer[::-1])
            break

        for nx in [x - 1, x + 1, 2 * x]:
            # 다음으로 이동할 위치가 방문한 적이 없고 제한범위를 초과하지 않는 경우
            if 0 <= nx < max and dist[nx] == -1:
                # 큐 삽입, 최소 시간 업데이트, 이전 노드 경로 추가
                queue.append(nx)
                dist[nx] = dist[x] + 1
                last[nx] = x

```
