## 백준 12851 숨바꼭질 2
[문제 링크](https://www.acmicpc.net/problem/12851)

## 문제
수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.

수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 그리고, 가장 빠른 시간으로 찾는 방법이 몇 가지 인지 구하는 프로그램을 작성하시오.

## 핵심 포인트
```
- 가장 빠른 시간을 구하는 것이므로 BFS 알고리즘을 사용한다.
- 빠른 시간으로 찾는 방법이 몇 가지인지 구해야하므로 현재 값이 동생의 위치와 같으면 횟수를 증가시켜준다.
- 수빈이와 동생이 갈 수 있는 위치를 고려하여 최솟값은 0, 최댓값은 100000로 설정한다.
- 현재 노드를 방문하지 않았거나 현재 노드에서 다음 노드로 이동했을 때 최단 시간이라면 큐에 삽입한다.
```

## 핵심 코드
```
def bfs(s):
    queue = deque()
    queue.append(s)
    dist[s] = 0
    min_cnt = 0

    while queue:
        now = queue.popleft()

        if now == k:
            min_cnt += 1

        for next in [now - 1, now + 1, now * 2]:
            if 0 <= next < max_val:
                if dist[next] == -1 or dist[next] == dist[now] + 1:
                    queue.append(next)
                    dist[next] = dist[now] + 1

    return min_cnt
```